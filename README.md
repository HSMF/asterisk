# Asterisk - LR(1) Parser Generator

Not the most efficient parser generator but it's cool, I guess<sup>TM</sup>

## Development

To run the generator, execute this:

```sh
dune exec -- ./main.exe
```

This will generate several files, TODO: only generate on demand

- `table.html`
- `hey.dot`
- `parser.js`
- `parser.java`

To generate a graph of the DFA, `graphviz` is required to be installed:

```sh
dot -Tsvg -{G,E,N}fontname=monospace -O hey.dot
```

## Grammar Specification Files

An Asterisk grammar specification file has the following structure

```
TARGET = target language
ENTRY = rule name
PRELUDE = {
  // your setup code goes here
}

# this is a line comment

rule: type
  | case 1 -> { expression if matched }
  | case 2 -> { expression if matched }
```

Supported values for `TARGET` are

- `ocaml`
- `java`
- `javascript` (or, equivalently, `js`)

A "literal" is a block of code, that is interpreted literally by asterisk. It is surrounded by `{`
and `}`. It may include the characters `{` and `}` but they must be balanced: `{ {} }` is a valid
literal while `{ } }` is not.

Identifiers (rules and terminals/non-terminals) must start with an alpha*betic* character or `_`,
optionally followed by alpha*numeric* characters or `_`

Cases are a white space separated list of identifiers. If the identifier matches the name of a rule,
it is treated as a non-terminal, otherwise it is treated as a token. The name of the token must
match with the name of the token generated by some lexer

The expression that is applied on match must be a valid expression in the target language. For more
information see the language specific expression rules (which are TBA)

## Usage In Ocaml

For every Token that carries some data, the type of that data must be specified via
`token_<token-id> = <type>`. For example: `token_Ident = string`

If using dune, add the following rule to your `dune` file.

```clojure
(rule
 (alias generate)
 (deps grammar.ast)
 (targets grammar.ml)
 (action (run asterisk grammar.ast -o grammar.ml))
)
```

## TODO

- actually usable cli interface
- custom grammars without recompiling the generator :D
  - grammar file format
- support more languages
- support N languages by establishing some table IR and emitting that ?
- lexer generator
- doc: language specific expression rules
- naming fields in grammar spec
  - `| left=Expr Plus right=Expr {left + right}`
  - equivalent to `| Expr Plus Expr {v0 + v2}`
  - requires:metadata for grammar
- automatically factor grammar to make it more lr(1)
  - requires:metadata for grammar
