
    (* Autogenerated file *)
open Lex
  exception Parse_error of string

  type states =
  | State_node1 | State_node10 | State_node11 | State_node12 | State_node13
  | State_node14 | State_node15 | State_node16 | State_node17 | State_node18
  | State_node19 | State_node2 | State_node20 | State_node21 | State_node22
  | State_node23 | State_node24 | State_node25 | State_node3 | State_node4
  | State_node5 | State_node6 | State_node7 | State_node8 | State_node9
  type stack_value =
  | StackValue_Case of (string list * string)
  | StackValue_CaseList of  (string list * string) list 
  | StackValue_Grammar of  (string * string * (string * string * (string list * string) list) list)  
  | StackValue_Idents of (string list)
  | StackValue_PreludeSpec of string
  | StackValue_Rule of  (string * string * (string list * string) list) 
  | StackValue_Rules of  (string * string * (string list * string) list) list 
  | StackValue_S0 of  (string * string * (string * string * (string list * string) list) list)  
  | StackValue_TargetSpec of string
    | StackValue_Ident of string
  | StackValue_Literal of string
  | StackValue_None

  type nonterm = Token_Case | Token_CaseList | Token_Grammar | Token_Idents | Token_PreludeSpec | Token_Rule | Token_Rules | Token_S0 | Token_TargetSpec
  type token_type = Term of token | NonTerm of nonterm | TermEof
  type stack = (states * token_type * stack_value) list

  let parse input =
    let pop msg = function
      | [] -> raise (Parse_error msg)
      | hd::tl -> hd, tl in
    let pop_stack a = pop "stack" a in
    let pop_input a = pop "input" a in

    let rec _hello = ()

    and goto_Case (state: states) =
              match state with
                | State_node11 -> node13, State_node13
                | State_node13 -> node13, State_node13
                | _ -> raise (Parse_error "couldn't match in goto Case")

    and goto_CaseList (state: states) =
              match state with
                | State_node11 -> node12, State_node12
                | State_node13 -> node14, State_node14
                | _ -> raise (Parse_error "couldn't match in goto CaseList")

    and goto_Grammar (state: states) =
              match state with
                | State_node1 -> node2, State_node2
                | _ -> raise (Parse_error "couldn't match in goto Grammar")

    and goto_Idents (state: states) =
              match state with
                | State_node15 -> node16, State_node16
                | State_node18 -> node19, State_node19
                | _ -> raise (Parse_error "couldn't match in goto Idents")

    and goto_PreludeSpec (state: states) =
              match state with
                | State_node4 -> node5, State_node5
                | _ -> raise (Parse_error "couldn't match in goto PreludeSpec")

    and goto_Rule (state: states) =
              match state with
                | State_node5 -> node7, State_node7
                | State_node7 -> node7, State_node7
                | _ -> raise (Parse_error "couldn't match in goto Rule")

    and goto_Rules (state: states) =
              match state with
                | State_node5 -> node6, State_node6
                | State_node7 -> node8, State_node8
                | _ -> raise (Parse_error "couldn't match in goto Rules")

    and goto_TargetSpec (state: states) =
              match state with
                | State_node1 -> node4, State_node4
                | _ -> raise (Parse_error "couldn't match in goto TargetSpec")

    and node1 (stack: stack) (input: token list) =
           match input with
             | (Target as head) :: input' -> begin
                let stack = (State_node23, Term head, StackValue_None) :: stack in
               node23 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`Target` (Target)} in state node1."))
      
    and node10 (stack: stack) (input: token list) =
           match input with
             | (Literal value as head) :: input' -> begin
                let stack = (State_node11, Term head, StackValue_Literal (value)) :: stack in
               node11 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`Literal` (Literal)} in state node10."))
      
    and node11 (stack: stack) (input: token list) =
           match input with
             | [ (* EOF *) ] as input' -> begin
                
                let value = ( [] ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_CaseList before in
                let stack = (goto_id, NonTerm Token_CaseList, StackValue_CaseList value) :: stack in
                goto stack input
             end
  
             | (Ident value as head) :: input' -> begin
                
                let value = ( [] ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_CaseList before in
                let stack = (goto_id, NonTerm Token_CaseList, StackValue_CaseList value) :: stack in
                goto stack input
             end
  
             | (Pipe as head) :: input' -> begin
                let stack = (State_node15, Term head, StackValue_None) :: stack in
               node15 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`$` ($), `Ident` (Ident), `Pipe` (Pipe)} in state node11."))
      
    and node12 (stack: stack) (input: token list) =
           match input with
             | [ (* EOF *) ] as input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v3 = (match typ, tmp with
                | NonTerm Token_CaseList, StackValue_CaseList v -> v
                | _ -> raise (Parse_error "expected token CaseList")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v2 = (match typ, tmp with
                | Term Literal _, StackValue_Literal v -> v
                | _ -> raise (Parse_error "expected token `Literal`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | Term Colon, StackValue_None -> ()
                | _ -> raise (Parse_error "expected token `Colon`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | Term Ident _, StackValue_Ident v -> v
                | _ -> raise (Parse_error "expected token `Ident`")) in
                let value = ( (v0, v2, v3) ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_Rule before in
                let stack = (goto_id, NonTerm Token_Rule, StackValue_Rule value) :: stack in
                goto stack input
             end
  
             | (Ident value as head) :: input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v3 = (match typ, tmp with
                | NonTerm Token_CaseList, StackValue_CaseList v -> v
                | _ -> raise (Parse_error "expected token CaseList")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v2 = (match typ, tmp with
                | Term Literal _, StackValue_Literal v -> v
                | _ -> raise (Parse_error "expected token `Literal`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | Term Colon, StackValue_None -> ()
                | _ -> raise (Parse_error "expected token `Colon`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | Term Ident _, StackValue_Ident v -> v
                | _ -> raise (Parse_error "expected token `Ident`")) in
                let value = ( (v0, v2, v3) ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_Rule before in
                let stack = (goto_id, NonTerm Token_Rule, StackValue_Rule value) :: stack in
                goto stack input
             end
  
             | _ -> raise (Parse_error ("expected one of {`$` ($), `Ident` (Ident)} in state node12."))
      
    and node13 (stack: stack) (input: token list) =
           match input with
             | [ (* EOF *) ] as input' -> begin
                
                let value = ( [] ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_CaseList before in
                let stack = (goto_id, NonTerm Token_CaseList, StackValue_CaseList value) :: stack in
                goto stack input
             end
  
             | (Ident value as head) :: input' -> begin
                
                let value = ( [] ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_CaseList before in
                let stack = (goto_id, NonTerm Token_CaseList, StackValue_CaseList value) :: stack in
                goto stack input
             end
  
             | (Pipe as head) :: input' -> begin
                let stack = (State_node15, Term head, StackValue_None) :: stack in
               node15 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`$` ($), `Ident` (Ident), `Pipe` (Pipe)} in state node13."))
      
    and node14 (stack: stack) (input: token list) =
           match input with
             | [ (* EOF *) ] as input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | NonTerm Token_CaseList, StackValue_CaseList v -> v
                | _ -> raise (Parse_error "expected token CaseList")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | NonTerm Token_Case, StackValue_Case v -> v
                | _ -> raise (Parse_error "expected token Case")) in
                let value = ( v0 :: v1 ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_CaseList before in
                let stack = (goto_id, NonTerm Token_CaseList, StackValue_CaseList value) :: stack in
                goto stack input
             end
  
             | (Ident value as head) :: input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | NonTerm Token_CaseList, StackValue_CaseList v -> v
                | _ -> raise (Parse_error "expected token CaseList")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | NonTerm Token_Case, StackValue_Case v -> v
                | _ -> raise (Parse_error "expected token Case")) in
                let value = ( v0 :: v1 ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_CaseList before in
                let stack = (goto_id, NonTerm Token_CaseList, StackValue_CaseList value) :: stack in
                goto stack input
             end
  
             | _ -> raise (Parse_error ("expected one of {`$` ($), `Ident` (Ident)} in state node14."))
      
    and node15 (stack: stack) (input: token list) =
           match input with
             | (Ident value as head) :: input' -> begin
                let stack = (State_node18, Term head, StackValue_Ident (value)) :: stack in
               node18 stack input'
             end
  
             | (Literal value as head) :: input' -> begin
                
                let value = ( [] ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_Idents before in
                let stack = (goto_id, NonTerm Token_Idents, StackValue_Idents value) :: stack in
                goto stack input
             end
  
             | _ -> raise (Parse_error ("expected one of {`Ident` (Ident), `Literal` (Literal)} in state node15."))
      
    and node16 (stack: stack) (input: token list) =
           match input with
             | (Literal value as head) :: input' -> begin
                let stack = (State_node17, Term head, StackValue_Literal (value)) :: stack in
               node17 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`Literal` (Literal)} in state node16."))
      
    and node17 (stack: stack) (input: token list) =
           match input with
             | [ (* EOF *) ] as input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v2 = (match typ, tmp with
                | Term Literal _, StackValue_Literal v -> v
                | _ -> raise (Parse_error "expected token `Literal`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | NonTerm Token_Idents, StackValue_Idents v -> v
                | _ -> raise (Parse_error "expected token Idents")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | Term Pipe, StackValue_None -> ()
                | _ -> raise (Parse_error "expected token `Pipe`")) in
                let value = ( v1, v2 ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_Case before in
                let stack = (goto_id, NonTerm Token_Case, StackValue_Case value) :: stack in
                goto stack input
             end
  
             | (Ident value as head) :: input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v2 = (match typ, tmp with
                | Term Literal _, StackValue_Literal v -> v
                | _ -> raise (Parse_error "expected token `Literal`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | NonTerm Token_Idents, StackValue_Idents v -> v
                | _ -> raise (Parse_error "expected token Idents")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | Term Pipe, StackValue_None -> ()
                | _ -> raise (Parse_error "expected token `Pipe`")) in
                let value = ( v1, v2 ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_Case before in
                let stack = (goto_id, NonTerm Token_Case, StackValue_Case value) :: stack in
                goto stack input
             end
  
             | (Pipe as head) :: input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v2 = (match typ, tmp with
                | Term Literal _, StackValue_Literal v -> v
                | _ -> raise (Parse_error "expected token `Literal`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | NonTerm Token_Idents, StackValue_Idents v -> v
                | _ -> raise (Parse_error "expected token Idents")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | Term Pipe, StackValue_None -> ()
                | _ -> raise (Parse_error "expected token `Pipe`")) in
                let value = ( v1, v2 ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_Case before in
                let stack = (goto_id, NonTerm Token_Case, StackValue_Case value) :: stack in
                goto stack input
             end
  
             | _ -> raise (Parse_error ("expected one of {`$` ($), `Ident` (Ident), `Pipe` (Pipe)} in state node17."))
      
    and node18 (stack: stack) (input: token list) =
           match input with
             | (Ident value as head) :: input' -> begin
                let stack = (State_node18, Term head, StackValue_Ident (value)) :: stack in
               node18 stack input'
             end
  
             | (Literal value as head) :: input' -> begin
                
                let value = ( [] ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_Idents before in
                let stack = (goto_id, NonTerm Token_Idents, StackValue_Idents value) :: stack in
                goto stack input
             end
  
             | _ -> raise (Parse_error ("expected one of {`Ident` (Ident), `Literal` (Literal)} in state node18."))
      
    and node19 (stack: stack) (input: token list) =
           match input with
             | (Literal value as head) :: input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | NonTerm Token_Idents, StackValue_Idents v -> v
                | _ -> raise (Parse_error "expected token Idents")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | Term Ident _, StackValue_Ident v -> v
                | _ -> raise (Parse_error "expected token `Ident`")) in
                let value = ( v0 :: v1 ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_Idents before in
                let stack = (goto_id, NonTerm Token_Idents, StackValue_Idents value) :: stack in
                goto stack input
             end
  
             | _ -> raise (Parse_error ("expected one of {`Literal` (Literal)} in state node19."))
      
    and node2 (stack: stack) (input: token list) =
           match input with
             | [ (* EOF *) ] as input' -> begin
                let stack = (State_node3, TermEof, StackValue_None) :: stack in
               node3 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`$` ($)} in state node2."))
      
    and node20 (stack: stack) (input: token list) =
           match input with
             | (Equals as head) :: input' -> begin
                let stack = (State_node21, Term head, StackValue_None) :: stack in
               node21 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`Equals` (Equals)} in state node20."))
      
    and node21 (stack: stack) (input: token list) =
           match input with
             | (Literal value as head) :: input' -> begin
                let stack = (State_node22, Term head, StackValue_Literal (value)) :: stack in
               node22 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`Literal` (Literal)} in state node21."))
      
    and node22 (stack: stack) (input: token list) =
           match input with
             | [ (* EOF *) ] as input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v2 = (match typ, tmp with
                | Term Literal _, StackValue_Literal v -> v
                | _ -> raise (Parse_error "expected token `Literal`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | Term Equals, StackValue_None -> ()
                | _ -> raise (Parse_error "expected token `Equals`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | Term Prelude, StackValue_None -> ()
                | _ -> raise (Parse_error "expected token `Prelude`")) in
                let value = (v2) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_PreludeSpec before in
                let stack = (goto_id, NonTerm Token_PreludeSpec, StackValue_PreludeSpec value) :: stack in
                goto stack input
             end
  
             | (Ident value as head) :: input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v2 = (match typ, tmp with
                | Term Literal _, StackValue_Literal v -> v
                | _ -> raise (Parse_error "expected token `Literal`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | Term Equals, StackValue_None -> ()
                | _ -> raise (Parse_error "expected token `Equals`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | Term Prelude, StackValue_None -> ()
                | _ -> raise (Parse_error "expected token `Prelude`")) in
                let value = (v2) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_PreludeSpec before in
                let stack = (goto_id, NonTerm Token_PreludeSpec, StackValue_PreludeSpec value) :: stack in
                goto stack input
             end
  
             | _ -> raise (Parse_error ("expected one of {`$` ($), `Ident` (Ident)} in state node22."))
      
    and node23 (stack: stack) (input: token list) =
           match input with
             | (Equals as head) :: input' -> begin
                let stack = (State_node24, Term head, StackValue_None) :: stack in
               node24 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`Equals` (Equals)} in state node23."))
      
    and node24 (stack: stack) (input: token list) =
           match input with
             | (Ident value as head) :: input' -> begin
                let stack = (State_node25, Term head, StackValue_Ident (value)) :: stack in
               node25 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`Ident` (Ident)} in state node24."))
      
    and node25 (stack: stack) (input: token list) =
           match input with
             | (Prelude as head) :: input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v2 = (match typ, tmp with
                | Term Ident _, StackValue_Ident v -> v
                | _ -> raise (Parse_error "expected token `Ident`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | Term Equals, StackValue_None -> ()
                | _ -> raise (Parse_error "expected token `Equals`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | Term Target, StackValue_None -> ()
                | _ -> raise (Parse_error "expected token `Target`")) in
                let value = (v2) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_TargetSpec before in
                let stack = (goto_id, NonTerm Token_TargetSpec, StackValue_TargetSpec value) :: stack in
                goto stack input
             end
  
             | _ -> raise (Parse_error ("expected one of {`Prelude` (Prelude)} in state node25."))
      
    and node3 (stack: stack) (input: token list) =
           match input with
             | [ (* EOF *) ] as input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | TermEof, StackValue_None -> ()
                | _ -> raise (Parse_error "expected token `$`")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | NonTerm Token_Grammar, StackValue_Grammar v -> v
                | _ -> raise (Parse_error "expected token Grammar")) in
                let value = (v0) in
                value
             end
  
             | _ -> raise (Parse_error ("expected one of {`$` ($)} in state node3."))
      
    and node4 (stack: stack) (input: token list) =
           match input with
             | (Prelude as head) :: input' -> begin
                let stack = (State_node20, Term head, StackValue_None) :: stack in
               node20 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`Prelude` (Prelude)} in state node4."))
      
    and node5 (stack: stack) (input: token list) =
           match input with
             | [ (* EOF *) ] as input' -> begin
                
                let value = ([]) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_Rules before in
                let stack = (goto_id, NonTerm Token_Rules, StackValue_Rules value) :: stack in
                goto stack input
             end
  
             | (Ident value as head) :: input' -> begin
                let stack = (State_node9, Term head, StackValue_Ident (value)) :: stack in
               node9 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`$` ($), `Ident` (Ident)} in state node5."))
      
    and node6 (stack: stack) (input: token list) =
           match input with
             | [ (* EOF *) ] as input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v2 = (match typ, tmp with
                | NonTerm Token_Rules, StackValue_Rules v -> v
                | _ -> raise (Parse_error "expected token Rules")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | NonTerm Token_PreludeSpec, StackValue_PreludeSpec v -> v
                | _ -> raise (Parse_error "expected token PreludeSpec")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | NonTerm Token_TargetSpec, StackValue_TargetSpec v -> v
                | _ -> raise (Parse_error "expected token TargetSpec")) in
                let value = ((v0, v1, v2)) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_Grammar before in
                let stack = (goto_id, NonTerm Token_Grammar, StackValue_Grammar value) :: stack in
                goto stack input
             end
  
             | _ -> raise (Parse_error ("expected one of {`$` ($)} in state node6."))
      
    and node7 (stack: stack) (input: token list) =
           match input with
             | [ (* EOF *) ] as input' -> begin
                
                let value = ([]) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_Rules before in
                let stack = (goto_id, NonTerm Token_Rules, StackValue_Rules value) :: stack in
                goto stack input
             end
  
             | (Ident value as head) :: input' -> begin
                let stack = (State_node9, Term head, StackValue_Ident (value)) :: stack in
               node9 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`$` ($), `Ident` (Ident)} in state node7."))
      
    and node8 (stack: stack) (input: token list) =
           match input with
             | [ (* EOF *) ] as input' -> begin
                let (_, typ, tmp), stack = pop_stack stack in
                let v1 = (match typ, tmp with
                | NonTerm Token_Rules, StackValue_Rules v -> v
                | _ -> raise (Parse_error "expected token Rules")) in
                let (_, typ, tmp), stack = pop_stack stack in
                let v0 = (match typ, tmp with
                | NonTerm Token_Rule, StackValue_Rule v -> v
                | _ -> raise (Parse_error "expected token Rule")) in
                let value = ( v0 :: v1 ) in
                
                let (before, _, _) = List.hd stack in
                let goto, goto_id = goto_Rules before in
                let stack = (goto_id, NonTerm Token_Rules, StackValue_Rules value) :: stack in
                goto stack input
             end
  
             | _ -> raise (Parse_error ("expected one of {`$` ($)} in state node8."))
      
    and node9 (stack: stack) (input: token list) =
           match input with
             | (Colon as head) :: input' -> begin
                let stack = (State_node10, Term head, StackValue_None) :: stack in
               node10 stack input'
             end
  
             | _ -> raise (Parse_error ("expected one of {`Colon` (Colon)} in state node9."))
      

    in

    node1 [State_node1, NonTerm Token_Case, StackValue_None] input

    
